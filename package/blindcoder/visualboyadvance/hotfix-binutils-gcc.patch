--- ./src/Gfx.h.orig	2004-10-10 10:50:57.000000000 +0200
+++ ./src/Gfx.h	2004-10-10 11:04:57.000000000 +0200
@@ -763,6 +763,8 @@
       case 3:
         sizeX = sizeY = 64;
         break;
+      default:
+      switch(((a0 >>12) & 0x0c)|(a1>>14)) {
       case 4:
         sizeX = 16;
         break;
@@ -777,6 +779,8 @@
         sizeX = 64;
         sizeY = 32;
         break;
+      default:
+      switch(((a0 >>12) & 0x0c)|(a1>>14)) {
       case 8:
         sizeY = 16;
         break;
@@ -793,6 +797,7 @@
         break;
       default:
         continue;
+      }}
       }
 
 #ifdef SPRITE_DEBUG
@@ -1167,6 +1172,8 @@
       case 3:
         sizeX = sizeY = 64;
         break;
+      default:
+      switch(((a0 >>12) & 0x0c)|(a1>>14)) {
       case 4:
         sizeX = 16;
         break;
@@ -1181,6 +1188,8 @@
         sizeX = 64;
         sizeY = 32;
         break;
+      default:
+      switch(((a0 >>12) & 0x0c)|(a1>>14)) {
       case 8:
         sizeY = 16;
         break;
@@ -1197,6 +1206,7 @@
         break;
       default:
         continue;
+      }}
       }
 
       int sy = (a0 & 255);
--- ./src/GBAinline.h.orig	2004-10-10 10:50:08.000000000 +0200
+++ ./src/GBAinline.h	2004-10-10 11:13:05.000000000 +0200
@@ -74,6 +74,8 @@
   case 3:
     value = READ32LE(((u32 *)&internalRAM[address & 0x7ffC]));
     break;
+  default:
+  switch(address >> 24) {
   case 4:
     if((address < 0x4000400) && ioReadable[address & 0x3fc]) {
       if(ioReadable[(address & 0x3fc) + 2])
@@ -91,10 +93,14 @@
   case 7:
     value = READ32LE(((u32 *)&oam[address & 0x3FC]));
     break;
+  default:
+  switch(address >> 24) {
   case 8:
   case 9:
   case 10:
   case 11:
+  default:
+  switch(address >> 24) {
   case 12:
     value = READ32LE(((u32 *)&rom[address&0x1FFFFFC]));
     break;    
@@ -128,6 +134,7 @@
       //      value = *((u32 *)&bios[address & 0x3ffc]);
       //    }
       //        return 0xFFFFFFFF;
+  }}}
   }
 
   if(address & 3) {
@@ -190,6 +197,8 @@
   case 3:
     value = READ16LE(((u16 *)&internalRAM[address & 0x7ffe]));
     break;
+  default:
+  switch(address >> 24) {
   case 4:
     if((address < 0x4000400) && ioReadable[address & 0x3fe])
       value =  READ16LE(((u16 *)&ioMem[address & 0x3fe]));
@@ -204,10 +213,14 @@
   case 7:
     value = READ16LE(((u16 *)&oam[address & 0x3fe]));
     break;
+  default:
+  switch(address >> 24) {
   case 8:
   case 9:
   case 10:
   case 11:
+  default:
+  switch(address >> 24) {
   case 12:
     if(address == 0x80000c4 || address == 0x80000c6 || address == 0x80000c8)
       value = rtcRead(address);
@@ -249,6 +262,7 @@
     //      value = (value >> 8) | ((value & 0xFF) << 24);
     //    return 0xFFFF;
     break;
+  }}}
   }
 
   if(address & 1) {
