diff -dur mysql-4.1.7/client/mysqltest.c src.mysql.1104350495.30814.396807788/mysql-4.1.7/client/mysqltest.c
--- mysql-4.1.7/client/mysqltest.c	2004-10-23 07:28:47.000000000 +0000
+++ src.mysql.1104350495.30814.396807788/mysql-4.1.7/client/mysqltest.c	2004-12-30 02:35:57.000000000 +0000
@@ -3272,8 +3272,8 @@
 static void make_sets_invisible(REP_SETS *sets);
 static void free_last_set(REP_SETS *sets);
 static void free_sets(REP_SETS *sets);
-static void set_bit(REP_SET *set, uint bit);
-static void clear_bit(REP_SET *set, uint bit);
+static void set_bit_(REP_SET *set, uint bit);
+static void clear_bit_(REP_SET *set, uint bit);
 static void or_bits(REP_SET *to,REP_SET *from);
 static void copy_bits(REP_SET *to,REP_SET *from);
 static int cmp_bits(REP_SET *set1,REP_SET *set2);
@@ -3350,7 +3350,7 @@
   {
     if (from[i][0] == '\\' && from[i][1] == '^')
     {
-      set_bit(start_states,states+1);
+      set_bit_(start_states,states+1);
       if (!from[i][2])
       {
 	start_states->table_offset=i;
@@ -3359,8 +3359,8 @@
     }
     else if (from[i][0] == '\\' && from[i][1] == '$')
     {
-      set_bit(start_states,states);
-      set_bit(word_states,states);
+      set_bit_(start_states,states);
+      set_bit_(word_states,states);
       if (!from[i][2] && start_states->table_offset == (uint) ~0)
       {
 	start_states->table_offset=i;
@@ -3369,11 +3369,11 @@
     }
     else
     {
-      set_bit(word_states,states);
+      set_bit_(word_states,states);
       if (from[i][0] == '\\' && (from[i][1] == 'b' && from[i][2]))
-	set_bit(start_states,states+1);
+	set_bit_(start_states,states+1);
       else
-	set_bit(start_states,states);
+	set_bit_(start_states,states);
     }
     for (pos=from[i], len=0; *pos ; pos++)
     {
@@ -3479,9 +3479,9 @@
 		follow[i].len > found_end)
 	      found_end=follow[i].len;
 	    if (chr && follow[i].chr)
-	      set_bit(new_set,i+1);		/* To next set */
+	      set_bit_(new_set,i+1);		/* To next set */
 	    else
-	      set_bit(new_set,i);
+	      set_bit_(new_set,i);
 	  }
 	}
 	if (found_end)
@@ -3498,7 +3498,7 @@
 	    if (follow[bit_nr-1].len < found_end ||
 		(new_set->found_len &&
 		 (chr == 0 || !follow[bit_nr].chr)))
-	      clear_bit(new_set,i);
+	      clear_bit_(new_set,i);
 	    else
 	    {
 	      if (chr == 0 || !follow[bit_nr].chr)
@@ -3647,13 +3647,13 @@
   return;
 }
 
-static void set_bit(REP_SET *set, uint bit)
+static void set_bit_(REP_SET *set, uint bit)
 {
   set->bits[bit / WORD_BIT] |= 1 << (bit % WORD_BIT);
   return;
 }
 
-static void clear_bit(REP_SET *set, uint bit)
+static void clear_bit_(REP_SET *set, uint bit)
 {
   set->bits[bit / WORD_BIT] &= ~ (1 << (bit % WORD_BIT));
   return;
diff -dur mysql-4.1.7/extra/replace.c src.mysql.1104350495.30814.396807788/mysql-4.1.7/extra/replace.c
--- mysql-4.1.7/extra/replace.c	2004-10-23 07:28:45.000000000 +0000
+++ src.mysql.1104350495.30814.396807788/mysql-4.1.7/extra/replace.c	2004-12-29 21:06:28.000000000 +0000
@@ -376,8 +376,8 @@
 static void make_sets_invisible(REP_SETS *sets);
 static void free_last_set(REP_SETS *sets);
 static void free_sets(REP_SETS *sets);
-static void set_bit(REP_SET *set, uint bit);
-static void clear_bit(REP_SET *set, uint bit);
+static void set_bit_(REP_SET *set, uint bit);
+static void clear_bit_(REP_SET *set, uint bit);
 static void or_bits(REP_SET *to,REP_SET *from);
 static void copy_bits(REP_SET *to,REP_SET *from);
 static int cmp_bits(REP_SET *set1,REP_SET *set2);
@@ -454,7 +454,7 @@
   {
     if (from[i][0] == '\\' && from[i][1] == '^')
     {
-      set_bit(start_states,states+1);
+      set_bit_(start_states,states+1);
       if (!from[i][2])
       {
 	start_states->table_offset=i;
@@ -463,8 +463,8 @@
     }
     else if (from[i][0] == '\\' && from[i][1] == '$')
     {
-      set_bit(start_states,states);
-      set_bit(word_states,states);
+      set_bit_(start_states,states);
+      set_bit_(word_states,states);
       if (!from[i][2] && start_states->table_offset == (uint) ~0)
       {
 	start_states->table_offset=i;
@@ -473,11 +473,11 @@
     }
     else
     {
-      set_bit(word_states,states);
+      set_bit_(word_states,states);
       if (from[i][0] == '\\' && (from[i][1] == 'b' && from[i][2]))
-	set_bit(start_states,states+1);
+	set_bit_(start_states,states+1);
       else
-	set_bit(start_states,states);
+	set_bit_(start_states,states);
     }
     for (pos=from[i], len=0; *pos ; pos++)
     {
@@ -583,9 +583,9 @@
 		follow[i].len > found_end)
 	      found_end=follow[i].len;
 	    if (chr && follow[i].chr)
-	      set_bit(new_set,i+1);		/* To next set */
+	      set_bit_(new_set,i+1);		/* To next set */
 	    else
-	      set_bit(new_set,i);
+	      set_bit_(new_set,i);
 	  }
 	}
 	if (found_end)
@@ -602,7 +602,7 @@
 	    if (follow[bit_nr-1].len < found_end ||
 		(new_set->found_len &&
 		 (chr == 0 || !follow[bit_nr].chr)))
-	      clear_bit(new_set,i);
+	      clear_bit_(new_set,i);
 	    else
 	    {
 	      if (chr == 0 || !follow[bit_nr].chr)
@@ -751,13 +751,13 @@
   return;
 }
 
-static void set_bit(REP_SET *set, uint bit)
+static void set_bit_(REP_SET *set, uint bit)
 {
   set->bits[bit / WORD_BIT] |= 1 << (bit % WORD_BIT);
   return;
 }
 
-static void clear_bit(REP_SET *set, uint bit)
+static void clear_bit_(REP_SET *set, uint bit)
 {
   set->bits[bit / WORD_BIT] &= ~ (1 << (bit % WORD_BIT));
   return;
diff -dur mysql-4.1.7/include/my_global.h src.mysql.1104350495.30814.396807788/mysql-4.1.7/include/my_global.h
--- mysql-4.1.7/include/my_global.h	2004-10-23 07:28:43.000000000 +0000
+++ src.mysql.1104350495.30814.396807788/mysql-4.1.7/include/my_global.h	2004-12-29 20:48:37.000000000 +0000
@@ -287,9 +287,8 @@
 #ifndef CONFIG_SMP
 #define CONFIG_SMP
 #endif
-C_MODE_START
+#define CONFIG_NR_CPUS 1
 #include <asm/atomic.h>
-C_MODE_END
 #endif
 #include <errno.h>				/* Recommended by debian */
 /* We need the following to go around a problem with openssl on solaris */
diff -dur mysql-4.1.7/libmysqld/examples/mysqltest.c src.mysql.1104350495.30814.396807788/mysql-4.1.7/libmysqld/examples/mysqltest.c
--- mysql-4.1.7/libmysqld/examples/mysqltest.c	2004-10-23 07:28:47.000000000 +0000
+++ src.mysql.1104350495.30814.396807788/mysql-4.1.7/libmysqld/examples/mysqltest.c	2004-12-30 02:35:57.000000000 +0000
@@ -3272,8 +3272,8 @@
 static void make_sets_invisible(REP_SETS *sets);
 static void free_last_set(REP_SETS *sets);
 static void free_sets(REP_SETS *sets);
-static void set_bit(REP_SET *set, uint bit);
-static void clear_bit(REP_SET *set, uint bit);
+static void set_bit_(REP_SET *set, uint bit);
+static void clear_bit_(REP_SET *set, uint bit);
 static void or_bits(REP_SET *to,REP_SET *from);
 static void copy_bits(REP_SET *to,REP_SET *from);
 static int cmp_bits(REP_SET *set1,REP_SET *set2);
@@ -3350,7 +3350,7 @@
   {
     if (from[i][0] == '\\' && from[i][1] == '^')
     {
-      set_bit(start_states,states+1);
+      set_bit_(start_states,states+1);
       if (!from[i][2])
       {
 	start_states->table_offset=i;
@@ -3359,8 +3359,8 @@
     }
     else if (from[i][0] == '\\' && from[i][1] == '$')
     {
-      set_bit(start_states,states);
-      set_bit(word_states,states);
+      set_bit_(start_states,states);
+      set_bit_(word_states,states);
       if (!from[i][2] && start_states->table_offset == (uint) ~0)
       {
 	start_states->table_offset=i;
@@ -3369,11 +3369,11 @@
     }
     else
     {
-      set_bit(word_states,states);
+      set_bit_(word_states,states);
       if (from[i][0] == '\\' && (from[i][1] == 'b' && from[i][2]))
-	set_bit(start_states,states+1);
+	set_bit_(start_states,states+1);
       else
-	set_bit(start_states,states);
+	set_bit_(start_states,states);
     }
     for (pos=from[i], len=0; *pos ; pos++)
     {
@@ -3479,9 +3479,9 @@
 		follow[i].len > found_end)
 	      found_end=follow[i].len;
 	    if (chr && follow[i].chr)
-	      set_bit(new_set,i+1);		/* To next set */
+	      set_bit_(new_set,i+1);		/* To next set */
 	    else
-	      set_bit(new_set,i);
+	      set_bit_(new_set,i);
 	  }
 	}
 	if (found_end)
@@ -3498,7 +3498,7 @@
 	    if (follow[bit_nr-1].len < found_end ||
 		(new_set->found_len &&
 		 (chr == 0 || !follow[bit_nr].chr)))
-	      clear_bit(new_set,i);
+	      clear_bit_(new_set,i);
 	    else
 	    {
 	      if (chr == 0 || !follow[bit_nr].chr)
@@ -3647,13 +3647,13 @@
   return;
 }
 
-static void set_bit(REP_SET *set, uint bit)
+static void set_bit_(REP_SET *set, uint bit)
 {
   set->bits[bit / WORD_BIT] |= 1 << (bit % WORD_BIT);
   return;
 }
 
-static void clear_bit(REP_SET *set, uint bit)
+static void clear_bit_(REP_SET *set, uint bit)
 {
   set->bits[bit / WORD_BIT] &= ~ (1 << (bit % WORD_BIT));
   return;
