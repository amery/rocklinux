#!/bin/bash

initrd_mount() { # {{{
	dev=${1}
	mntpoint=${2}

	/sbin/fsck -C -a ${dev}
	fsckrc=${?}
	if [ ${fsckrc} -eq 8 ] ; then
		return 1
	fi
	if   [ $(( ${fsckrc} & ~3 )) != 0 ] ; then
		echo " **"
		echo " ** Filesystem ${dev} || error=${?} failed (returncode=${fsckrc})."
		echo " ** Please repair the broken disk(s) manually."
		echo " **"
		exec /bin/bash
	elif [ $(( ${fsckrc} &  2 )) != 0 ] ; then
		echo " **"
		echo " ** fsck has requested the system to be rebooted."
		echo " ** Running a shell."
		echo " **"
		echo
		exec /bin/bash
	fi

	mount -n ${dev} ${mntpoint}
	return ${?}
} # }}}

PATH="/sbin:/usr/sbin:/bin/:/usr/bin"

rootfs=""
rootfsmounted=0

mount -n -t tmpfs tmpfs /tmp || echo "Can't mount tmpfs!"
mount -n -t proc proc /proc  || echo "Can't mount procfs!"
mount -n -t sysfs sysfs /sys || echo "Can't mount sysfs!"
mount -n -t ramfs ramfs /dev || echo "Can't mount ramfs!"
/sbin/udevstart
echo "/sbin/udevsend" > /proc/sys/kernel/hotplug
cd /dev
rm -rf fd
ln -sf /proc/self/fd
mkdir -p pts shm
cd /

if [ -n "${real_root}" ] ; then
	rootfs=${real_root}
else
	while read dev mntpoint fstype options fsck1 fsck2 ; do
		[ "${mntpoint}" == "/" ] && rootfs=${dev}
		[ -n "${rootfs}" ] && break
	done < /etc/fstab
fi

echo "loading kernel modules"
. /etc/conf/kernel
# some devices need time...
echo "waiting for devices to settle..."
sleep 2
/sbin/udevstart

for x in /etc/conf/* ; do
	[ "${x}" == "/etc/conf/kernel" ] && continue
	echo "Running ${x} ..."
	. ${x}
done

if [ ${rootfsmounted} -eq 0 ] ; then
	echo "Mounting rootfs (${rootfs}) on /root"
	initrd_mount ${rootfs} /root
	rootfsmounted=1
fi

[ -z "$real_init" ] && real_init="/sbin/init"

echo "starting $real_init in /root"
echo "parameters passed to $real_init: ${@}"
cd /root
mkdir -p /root/initrd
mount -n --move /tmp /root/tmp
mount -n --move /proc /root/proc
mount -n --move /sys /root/sys
mount -n --move /dev /root/dev
/sbin/pivot_root . initrd
exec chroot . $real_init "${@}" < /dev/console > /dev/console 2>&1
